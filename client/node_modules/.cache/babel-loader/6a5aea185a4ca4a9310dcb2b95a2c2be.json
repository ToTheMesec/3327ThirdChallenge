{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\Luka\\\\Desktop\\\\SupportChildrenV2.0\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar createHash = _interopDefault(require('create-hash'));\n\nvar pbkdf2 = _interopDefault(require('pbkdf2'));\n\nvar randombytes = _interopDefault(require('randombytes'));\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar emptyModule = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\nvar src = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  var DEFAULT_WORDLIST = emptyModule._default;\n  var INVALID_MNEMONIC = 'Invalid mnemonic';\n  var INVALID_ENTROPY = 'Invalid entropy';\n  var INVALID_CHECKSUM = 'Invalid mnemonic checksum';\n  var WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' + 'Please explicitly pass a 2048 word array explicitly.';\n\n  function lpad(str, padString, length) {\n    while (str.length < length) {\n      str = padString + str;\n    }\n\n    return str;\n  }\n\n  function binaryToByte(bin) {\n    return parseInt(bin, 2);\n  }\n\n  function bytesToBinary(bytes) {\n    return bytes.map(function (x) {\n      return lpad(x.toString(2), '0', 8);\n    }).join('');\n  }\n\n  function deriveChecksumBits(entropyBuffer) {\n    var ENT = entropyBuffer.length * 8;\n    var CS = ENT / 32;\n    var hash = createHash('sha256').update(entropyBuffer).digest();\n    return bytesToBinary(_toConsumableArray(hash)).slice(0, CS);\n  }\n\n  function salt(password) {\n    return 'mnemonic' + (password || '');\n  }\n\n  function mnemonicToSeedSync(mnemonic, password) {\n    var mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');\n    var saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');\n    return pbkdf2.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n  }\n\n  exports.mnemonicToSeedSync = mnemonicToSeedSync;\n\n  function mnemonicToSeed(mnemonic, password) {\n    return new Promise(function (resolve, reject) {\n      try {\n        var mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');\n        var saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');\n        pbkdf2.pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512', function (err, data) {\n          if (err) return reject(err);else return resolve(data);\n        });\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  }\n\n  exports.mnemonicToSeed = mnemonicToSeed;\n\n  function mnemonicToEntropy(mnemonic, wordlist) {\n    wordlist = wordlist || DEFAULT_WORDLIST;\n\n    if (!wordlist) {\n      throw new Error(WORDLIST_REQUIRED);\n    }\n\n    var words = (mnemonic || '').normalize('NFKD').split(' ');\n    if (words.length % 3 !== 0) throw new Error(INVALID_MNEMONIC); // convert word indices to 11 bit binary strings\n\n    var bits = words.map(function (word) {\n      var index = wordlist.indexOf(word);\n      if (index === -1) throw new Error(INVALID_MNEMONIC);\n      return lpad(index.toString(2), '0', 11);\n    }).join(''); // split the binary string into ENT/CS\n\n    var dividerIndex = Math.floor(bits.length / 33) * 32;\n    var entropyBits = bits.slice(0, dividerIndex);\n    var checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare\n\n    var entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n    if (entropyBytes.length < 16) throw new Error(INVALID_ENTROPY);\n    if (entropyBytes.length > 32) throw new Error(INVALID_ENTROPY);\n    if (entropyBytes.length % 4 !== 0) throw new Error(INVALID_ENTROPY);\n    var entropy = Buffer.from(entropyBytes);\n    var newChecksum = deriveChecksumBits(entropy);\n    if (newChecksum !== checksumBits) throw new Error(INVALID_CHECKSUM);\n    return entropy.toString('hex');\n  }\n\n  exports.mnemonicToEntropy = mnemonicToEntropy;\n\n  function entropyToMnemonic(entropy, wordlist) {\n    if (!Buffer.isBuffer(entropy)) entropy = Buffer.from(entropy, 'hex');\n    wordlist = wordlist || DEFAULT_WORDLIST;\n\n    if (!wordlist) {\n      throw new Error(WORDLIST_REQUIRED);\n    } // 128 <= ENT <= 256\n\n\n    if (entropy.length < 16) throw new TypeError(INVALID_ENTROPY);\n    if (entropy.length > 32) throw new TypeError(INVALID_ENTROPY);\n    if (entropy.length % 4 !== 0) throw new TypeError(INVALID_ENTROPY);\n    var entropyBits = bytesToBinary(_toConsumableArray(entropy));\n    var checksumBits = deriveChecksumBits(entropy);\n    var bits = entropyBits + checksumBits;\n    var chunks = bits.match(/(.{1,11})/g);\n    var words = chunks.map(function (binary) {\n      var index = binaryToByte(binary);\n      return wordlist[index];\n    });\n    return wordlist[0] === \"\\u3042\\u3044\\u3053\\u304F\\u3057\\u3093\" // Japanese wordlist\n    ? words.join(\"\\u3000\") : words.join(' ');\n  }\n\n  exports.entropyToMnemonic = entropyToMnemonic;\n\n  function generateMnemonic(strength, rng, wordlist) {\n    strength = strength || 128;\n    if (strength % 32 !== 0) throw new TypeError(INVALID_ENTROPY);\n    rng = rng || randombytes;\n    return entropyToMnemonic(rng(strength / 8), wordlist);\n  }\n\n  exports.generateMnemonic = generateMnemonic;\n\n  function validateMnemonic(mnemonic, wordlist) {\n    try {\n      mnemonicToEntropy(mnemonic, wordlist);\n    } catch (e) {\n      return false;\n    }\n\n    return true;\n  }\n\n  exports.validateMnemonic = validateMnemonic;\n\n  function setDefaultWordlist(language) {\n    var result = emptyModule.wordlists[language];\n    if (result) DEFAULT_WORDLIST = result;else throw new Error('Could not find wordlist for language \"' + language + '\"');\n  }\n\n  exports.setDefaultWordlist = setDefaultWordlist;\n\n  function getDefaultWordlist() {\n    if (!DEFAULT_WORDLIST) throw new Error('No Default Wordlist set');\n    return Object.keys(emptyModule.wordlists).filter(function (lang) {\n      if (lang === 'JA' || lang === 'EN') return false;\n      return emptyModule.wordlists[lang].every(function (word, index) {\n        return word === DEFAULT_WORDLIST[index];\n      });\n    })[0];\n  }\n\n  exports.getDefaultWordlist = getDefaultWordlist;\n  var _wordlists_2 = emptyModule;\n  exports.wordlists = _wordlists_2.wordlists;\n});\nvar index = unwrapExports(src);\nvar src_1 = src.mnemonicToSeedSync;\nvar src_2 = src.mnemonicToSeed;\nvar src_3 = src.mnemonicToEntropy;\nvar src_4 = src.entropyToMnemonic;\nvar src_5 = src.generateMnemonic;\nvar src_6 = src.validateMnemonic;\nvar src_7 = src.setDefaultWordlist;\nvar src_8 = src.getDefaultWordlist;\nvar src_9 = src.wordlists;\nexports.default = index;\nexports.entropyToMnemonic = src_4;\nexports.generateMnemonic = src_5;\nexports.getDefaultWordlist = src_8;\nexports.mnemonicToEntropy = src_3;\nexports.mnemonicToSeed = src_2;\nexports.mnemonicToSeedSync = src_1;\nexports.setDefaultWordlist = src_7;\nexports.validateMnemonic = src_6;\nexports.wordlists = src_9;","map":null,"metadata":{},"sourceType":"script"}