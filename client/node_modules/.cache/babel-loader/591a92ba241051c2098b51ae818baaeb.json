{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Luka\\\\Desktop\\\\SupportChildrenV2.0\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Luka\\\\Desktop\\\\SupportChildrenV2.0\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Luka\\\\Desktop\\\\SupportChildrenV2.0\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar bip39 = __importStar(require(\"ethereum-cryptography/bip39\"));\n\nvar english_1 = require(\"ethereum-cryptography/bip39/wordlists/english\");\n\nvar EthUtil = __importStar(require(\"ethereumjs-util\"));\n\nvar ethereumjs_wallet_1 = __importDefault(require(\"ethereumjs-wallet\"));\n\nvar ethereumjs_wallet_2 = require(\"ethereumjs-wallet\");\n\nvar ethereumjs_tx_1 = require(\"ethereumjs-tx\");\n\nvar ethereumjs_common_1 = __importDefault(require(\"ethereumjs-common\")); // @ts-ignore\n\n\nvar web3_provider_engine_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine\"));\n\nvar filters_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/filters\"));\n\nvar nonce_tracker_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/nonce-tracker\"));\n\nvar hooked_wallet_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/hooked-wallet\"));\n\nvar provider_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/provider\")); // @ts-ignore\n\n\nvar rpc_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/rpc\")); // @ts-ignore\n\n\nvar websocket_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/websocket\"));\n\nvar url_1 = __importDefault(require(\"url\"));\n\nvar getOptions_1 = require(\"./constructor/getOptions\");\n\nvar getPrivateKeys_1 = require(\"./constructor/getPrivateKeys\");\n\nvar getMnemonic_1 = require(\"./constructor/getMnemonic\"); // Important: do not use debug module. Reason: https://github.com/trufflesuite/truffle/issues/2374#issuecomment-536109086\n// This line shares nonce state across multiple provider instances. Necessary\n// because within truffle the wallet is repeatedly newed if it's declared in the config within a\n// function, resetting nonce from tx to tx. An instance can opt out\n// of this behavior by passing `shareNonce=false` to the constructor.\n// See issue #65 for more\n\n\nvar singletonNonceSubProvider = new nonce_tracker_1.default();\n\nvar HDWalletProvider = /*#__PURE__*/function () {\n  function HDWalletProvider() {\n    _classCallCheck(this, HDWalletProvider);\n\n    var _a = getOptions_1.getOptions.apply(getOptions_1, arguments),\n        providerOrUrl = _a.providerOrUrl,\n        _a$addressIndex = _a.addressIndex,\n        addressIndex = _a$addressIndex === void 0 ? 0 : _a$addressIndex,\n        _a$numberOfAddresses = _a.numberOfAddresses,\n        numberOfAddresses = _a$numberOfAddresses === void 0 ? 10 : _a$numberOfAddresses,\n        _a$shareNonce = _a.shareNonce,\n        shareNonce = _a$shareNonce === void 0 ? true : _a$shareNonce,\n        _a$derivationPath = _a.derivationPath,\n        derivationPath = _a$derivationPath === void 0 ? \"m/44'/60'/0'/0/\" : _a$derivationPath,\n        _a$pollingInterval = _a.pollingInterval,\n        pollingInterval = _a$pollingInterval === void 0 ? 4000 : _a$pollingInterval,\n        chainId = _a.chainId,\n        _a$chainSettings = _a.chainSettings,\n        chainSettings = _a$chainSettings === void 0 ? {} : _a$chainSettings,\n        signingAuthority = __rest(_a, [\"providerOrUrl\", \"addressIndex\", \"numberOfAddresses\", \"shareNonce\", \"derivationPath\", \"pollingInterval\", \"chainId\", \"chainSettings\"]);\n\n    var mnemonic = getMnemonic_1.getMnemonic(signingAuthority);\n    var privateKeys = getPrivateKeys_1.getPrivateKeys(signingAuthority);\n    this.walletHdpath = derivationPath;\n    this.wallets = {};\n    this.addresses = [];\n    this.chainSettings = chainSettings;\n    this.engine = new web3_provider_engine_1.default({\n      pollingInterval: pollingInterval\n    });\n\n    if (!HDWalletProvider.isValidProvider(providerOrUrl)) {\n      throw new Error([\"Malformed provider URL: '\".concat(providerOrUrl, \"'\"), \"Please specify a correct URL, using the http, https, ws, or wss protocol.\", \"\"].join(\"\\n\"));\n    }\n\n    if (mnemonic && mnemonic.phrase) {\n      this.checkBIP39Mnemonic(Object.assign(Object.assign({}, mnemonic), {\n        addressIndex: addressIndex,\n        numberOfAddresses: numberOfAddresses\n      }));\n    } else if (privateKeys) {\n      var options = Object.assign({}, {\n        privateKeys: privateKeys\n      }, {\n        addressIndex: addressIndex\n      });\n      this.ethUtilValidation(options);\n    } // no need to handle else case here, since matchesNewOptions() covers it\n\n\n    if (this.addresses.length === 0) {\n      throw new Error(\"Could not create addresses from your mnemonic or private key(s). \" + \"Please check that your inputs are correct.\");\n    }\n\n    var tmpAccounts = this.addresses;\n    var tmpWallets = this.wallets; // if user supplied the chain id, use that - otherwise fetch it\n\n    if (typeof chainId !== \"undefined\" || chainSettings && typeof chainSettings.chainId !== \"undefined\") {\n      this.chainId = chainId || chainSettings.chainId;\n      this.initialized = Promise.resolve();\n    } else {\n      this.initialized = this.initialize();\n    } // EIP155 compliant transactions are enabled for hardforks later\n    // than or equal to \"spurious dragon\"\n\n\n    this.hardfork = chainSettings && chainSettings.hardfork ? chainSettings.hardfork : \"istanbul\";\n    var self = this;\n    this.engine.addProvider(new hooked_wallet_1.default({\n      getAccounts: function getAccounts(cb) {\n        cb(null, tmpAccounts);\n      },\n      getPrivateKey: function getPrivateKey(address, cb) {\n        if (!tmpWallets[address]) {\n          return cb(\"Account not found\");\n        } else {\n          cb(null, tmpWallets[address].getPrivateKey().toString(\"hex\"));\n        }\n      },\n      signTransaction: function signTransaction(txParams, cb) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var pkey, from, chain, KNOWN_CHAIN_IDS, txOptions, common, tx, rawTx;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return self.initialized;\n\n                case 2:\n                  // we need to rename the 'gas' field\n                  txParams.gasLimit = txParams.gas;\n                  delete txParams.gas;\n                  from = txParams.from.toLowerCase();\n\n                  if (tmpWallets[from]) {\n                    pkey = tmpWallets[from].getPrivateKey();\n                  } else {\n                    cb(\"Account not found\");\n                  }\n\n                  chain = self.chainId;\n                  KNOWN_CHAIN_IDS = new Set([1, 3, 4, 5, 42]);\n\n                  if (typeof chain !== \"undefined\" && KNOWN_CHAIN_IDS.has(chain)) {\n                    txOptions = {\n                      chain: chain\n                    };\n                  } else if (typeof chain !== \"undefined\") {\n                    common = ethereumjs_common_1.default.forCustomChain(1, {\n                      name: \"custom chain\",\n                      chainId: chain\n                    }, self.hardfork);\n                    txOptions = {\n                      common: common\n                    };\n                  }\n\n                  tx = new ethereumjs_tx_1.Transaction(txParams, txOptions);\n                  tx.sign(pkey);\n                  rawTx = \"0x\".concat(tx.serialize().toString(\"hex\"));\n                  cb(null, rawTx);\n\n                case 13:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n      },\n      signMessage: function signMessage(_ref, cb) {\n        var data = _ref.data,\n            from = _ref.from;\n        var dataIfExists = data;\n\n        if (!dataIfExists) {\n          cb(\"No data to sign\");\n        }\n\n        if (!tmpWallets[from]) {\n          cb(\"Account not found\");\n        }\n\n        var pkey = tmpWallets[from].getPrivateKey();\n        var dataBuff = EthUtil.toBuffer(dataIfExists);\n        var msgHashBuff = EthUtil.hashPersonalMessage(dataBuff);\n        var sig = EthUtil.ecsign(msgHashBuff, pkey);\n        var rpcSig = EthUtil.toRpcSig(sig.v, sig.r, sig.s);\n        cb(null, rpcSig);\n      },\n      signPersonalMessage: function signPersonalMessage() {\n        this.signMessage.apply(this, arguments);\n      }\n    }));\n    !shareNonce ? this.engine.addProvider(new nonce_tracker_1.default()) : this.engine.addProvider(singletonNonceSubProvider);\n    this.engine.addProvider(new filters_1.default());\n\n    if (typeof providerOrUrl === \"string\") {\n      var url = providerOrUrl;\n      var providerProtocol = (url_1.default.parse(url).protocol || \"http:\").toLowerCase();\n\n      switch (providerProtocol) {\n        case \"ws:\":\n        case \"wss:\":\n          this.engine.addProvider(new websocket_1.default({\n            rpcUrl: url\n          }));\n          break;\n\n        default:\n          this.engine.addProvider(new rpc_1.default({\n            rpcUrl: url\n          }));\n      }\n    } else {\n      var provider = providerOrUrl;\n      this.engine.addProvider(new provider_1.default(provider));\n    } // Required by the provider engine.\n\n\n    this.engine.start(function (err) {\n      if (err) throw err;\n    });\n  }\n\n  _createClass(HDWalletProvider, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        _this.engine.sendAsync({\n          jsonrpc: '2.0',\n          id: Date.now(),\n          method: 'eth_chainId',\n          params: []\n        }, function (error, response) {\n          if (error) {\n            reject(error);\n            return;\n          } else if (response.error) {\n            reject(response.error);\n            return;\n          }\n\n          if (isNaN(parseInt(response.result, 16))) {\n            var message = \"When requesting the chain id from the node, it\" + \"returned the malformed result \".concat(response.result, \".\");\n            throw new Error(message);\n          }\n\n          _this.chainId = parseInt(response.result, 16);\n          resolve();\n        });\n      });\n    } // private helper to check if given mnemonic uses BIP39 passphrase protection\n\n  }, {\n    key: \"checkBIP39Mnemonic\",\n    value: function checkBIP39Mnemonic(_ref2) {\n      var addressIndex = _ref2.addressIndex,\n          numberOfAddresses = _ref2.numberOfAddresses,\n          phrase = _ref2.phrase,\n          password = _ref2.password;\n      this.hdwallet = ethereumjs_wallet_2.hdkey.fromMasterSeed(bip39.mnemonicToSeedSync(phrase, password));\n\n      if (!bip39.validateMnemonic(phrase, english_1.wordlist)) {\n        throw new Error(\"Mnemonic invalid or undefined\");\n      } // crank the addresses out\n\n\n      for (var i = addressIndex; i < addressIndex + numberOfAddresses; i++) {\n        var wallet = this.hdwallet.derivePath(this.walletHdpath + i).getWallet();\n        var addr = \"0x\".concat(wallet.getAddress().toString(\"hex\"));\n        this.addresses.push(addr);\n        this.wallets[addr] = wallet;\n      }\n    } // private helper leveraging ethUtils to populate wallets/addresses\n\n  }, {\n    key: \"ethUtilValidation\",\n    value: function ethUtilValidation(_ref3) {\n      var addressIndex = _ref3.addressIndex,\n          privateKeys = _ref3.privateKeys;\n\n      // crank the addresses out\n      for (var i = addressIndex; i < privateKeys.length; i++) {\n        var privateKey = Buffer.from(privateKeys[i].replace(\"0x\", \"\"), \"hex\");\n\n        if (EthUtil.isValidPrivate(privateKey)) {\n          var wallet = ethereumjs_wallet_1.default.fromPrivateKey(privateKey);\n          var address = wallet.getAddressString();\n          this.addresses.push(address);\n          this.wallets[address] = wallet;\n        }\n      }\n    }\n  }, {\n    key: \"send\",\n    value: function send(payload, callback) {\n      var _this2 = this;\n\n      this.initialized.then(function () {\n        _this2.engine.send(payload, callback);\n      });\n    }\n  }, {\n    key: \"sendAsync\",\n    value: function sendAsync(payload, callback) {\n      var _this3 = this;\n\n      this.initialized.then(function () {\n        _this3.engine.sendAsync(payload, callback);\n      });\n    }\n  }, {\n    key: \"getAddress\",\n    value: function getAddress(idx) {\n      if (!idx) {\n        return this.addresses[0];\n      } else {\n        return this.addresses[idx];\n      }\n    }\n  }, {\n    key: \"getAddresses\",\n    value: function getAddresses() {\n      return this.addresses;\n    }\n  }], [{\n    key: \"isValidProvider\",\n    value: function isValidProvider(provider) {\n      var validProtocols = [\"http:\", \"https:\", \"ws:\", \"wss:\"];\n\n      if (typeof provider === \"string\") {\n        var url = url_1.default.parse(provider.toLowerCase());\n        return !!(validProtocols.includes(url.protocol || \"\") && url.slashes);\n      }\n\n      return true;\n    }\n  }]);\n\n  return HDWalletProvider;\n}();\n\nmodule.exports = HDWalletProvider;","map":null,"metadata":{},"sourceType":"script"}