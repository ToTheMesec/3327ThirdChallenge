{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Luka\\\\Desktop\\\\SupportChildrenV2.0\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOptions = void 0;\n\nvar bip39_1 = require(\"ethereum-cryptography/bip39\");\n\nvar english_1 = require(\"ethereum-cryptography/bip39/wordlists/english\"); // check that the first argument is a mnemonic phrase\n\n\nvar isMnemonicPhrase = function isMnemonicPhrase(credentials) {\n  return typeof credentials === \"string\" && bip39_1.validateMnemonic(credentials, english_1.wordlist);\n}; // check that the first argument is a list of private keys\n\n\nvar isPrivateKeys = function isPrivateKeys(credentials) {\n  return credentials instanceof Array;\n}; // check that the first argument is a single private key (default case for invalid mnemonics)\n\n\nvar isPrivateKey = function isPrivateKey(credentials) {\n  return !isPrivateKeys(credentials) && !isMnemonicPhrase(credentials);\n}; // turn polymorphic first argument into { mnemonic } or { privateKeys }\n\n\nvar getSigningAuthorityOptions = function getSigningAuthorityOptions(credentials) {\n  if (isMnemonicPhrase(credentials)) {\n    return {\n      mnemonic: {\n        phrase: credentials\n      }\n    };\n  } else if (isPrivateKeys(credentials)) {\n    return {\n      privateKeys: credentials\n    };\n  } else if (isPrivateKey(credentials)) {\n    // if(...) included for explicitness\n    return {\n      privateKeys: [credentials]\n    };\n  } else {\n    // this won't be reached until/unless we validate private key(s)\n    throw new Error(\"First argument to new HDWalletProvider() must be a mnemonic phrase, a \" + \"single private key, or a list of private keys. \" + \"Received: \".concat(JSON.stringify(credentials)));\n  }\n};\n\nvar fromInputOptions = function fromInputOptions(options) {\n  if (\"mnemonic\" in options && typeof options.mnemonic === \"string\") {\n    return Object.assign(Object.assign({}, options), {\n      mnemonic: {\n        phrase: options.mnemonic\n      }\n    });\n  } else {\n    return options;\n  }\n}; // convert legacy style positional arguments to new, single-arg options format\n\n\nvar fromArguments = function fromArguments(args) {\n  // otherwise, if arguments match the old-style, extract properties and handle polymorphism\n  var _args = _slicedToArray(args, 7),\n      mnemonicPhraseOrPrivateKeys = _args[0],\n      providerOrUrl = _args[1],\n      addressIndex = _args[2],\n      numberOfAddresses = _args[3],\n      shareNonce = _args[4],\n      derivationPath = _args[5],\n      chainId = _args[6];\n\n  var signingAuthority = getSigningAuthorityOptions(mnemonicPhraseOrPrivateKeys);\n  return Object.assign(Object.assign({}, signingAuthority), {\n    providerOrUrl: providerOrUrl,\n    addressIndex: addressIndex,\n    numberOfAddresses: numberOfAddresses,\n    shareNonce: shareNonce,\n    derivationPath: derivationPath,\n    chainId: chainId\n  });\n}; // type predicate guard to determine at runtime if arguments conform to\n// new-style constructor args.\n\n\nvar matchesNewInputOptions = function matchesNewInputOptions(args) {\n  // new-style means exactly one argument\n  if (args.length !== 1) {\n    return false;\n  }\n\n  var _args2 = _slicedToArray(args, 1),\n      options = _args2[0]; // beyond that, determine based on property inclusion check for required keys\n\n\n  return \"providerOrUrl\" in options && (\"privateKeys\" in options || \"mnemonic\" in options);\n}; // type predicate guard to determine at runtime if arguments conform to\n// old-style constructor args.\n\n\nvar matchesLegacyArguments = function matchesLegacyArguments(args) {\n  return (// first check for alternate (new-style) case for basic determination\n    !matchesNewInputOptions(args) && // then additionally make sure we have the two required options we need\n    args.filter(function (arg) {\n      return arg !== undefined;\n    }).length >= 2\n  );\n}; // normalize arguments passed to constructor to match single, new-style options\n// argument\n\n\nvar getOptions = function getOptions() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (matchesNewInputOptions(args)) {\n    // if arguments already match new-style, no real transformation needed\n    var options = args[0];\n    return fromInputOptions(options);\n  } else if (matchesLegacyArguments(args)) {\n    return fromArguments(args);\n  } else {\n    throw new Error(\"Unknown arguments format passed to new HDWalletProvider. Please check your configuration and try again\");\n  }\n};\n\nexports.getOptions = getOptions;","map":null,"metadata":{},"sourceType":"script"}